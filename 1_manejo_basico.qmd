---
title: "IntroducciÃ³n al paquete {targets}"
subtitle: "Manejo bÃ¡sico"
author: "Depto. Data Science<br>Okuant"
date: today
---
# IntroducciÃ³n

## QuÃ© es targets

El paquete targets es una herramienta de flujo de trabajo similar a Make para la estadÃ­stica y la ciencia de los datos en R. Con targets, se puede mantener un flujo de trabajo reproducible sin repetirse. Entre sus principales caracterÃ­sticas estÃ¡ el evitar la ejecuciÃ³n de tareas que ya estÃ¡n actualizadas, ejecutando sÃ³lo el cÃ¡lculo necesario. AdemÃ¡s, admite computaciÃ³n paralela implÃ­cita, abstrae los archivos como objetos de R y muestra pruebas tangibles de que los resultados coinciden con el cÃ³digo y los datos subyacentes.

## Estructura del proyecto

Se sigue la estructura bÃ¡sica de un proyecto de R:

```
ğŸ“¦ targets_tutorial
 â”£ ğŸ“‚ data                      # Datos necesarios para el proyecto
 â”ƒ  â”— ğŸ“‚ raw                 
 â”£ ğŸ“‚ src                       # Archivos de cÃ³digo especÃ­fico
 â”ƒ  â”— ğŸ“œ functions.R
 â”£ ğŸ“‚ _targets                  # Datos y metadatos de targets
 â”£ ğŸ“œ _targets.R                # DefiniciÃ³n del pipeline
 â”£ ğŸ“œ README.md                 # Descripcion del proyecto
 â”£ ğŸ“œ main.R                    # Script para lanzar el pipeline
 â”— ğŸ“œ .gitignore

```

## El archivo `_targets.R`
El corazÃ³n de `targets`, donde definimos el _pipeline_:
```{r, eval = FALSE, echo = TRUE}
# Load packages required to define the pipeline:
library(targets)
library(tarchetypes)
library(data.table)
library(magrittr)


# Set target options:
tar_option_set(
  packages = c("ggplot2"), # packages that your targets need to run
  format = "rds"           # default storage format
)

# Load the R scripts with your custom functions:
source("src/functions.R")
# Or source everything in src/ folder:
# lapply(list.files("src", full.names = TRUE, recursive = TRUE), source)

# Define sub-pipeline (input)
input_pl <- list(
  tar_target(exams_file, "data/raw/exams.csv", format = "file")
)

# Define sub-pipeline (main)
main_pl <- list(
  tar_target(
    exams,
    exams_file %>% 
      fread() %>% 
      rename_data()
  ),
  
  tar_target(
    model,
    fit_model(exams)
  ),
  
  tar_target(
    plot,
    plot_model(exams, model)
  )
)

out_pl <- list(
  tar_quarto(
    ex_report,
    "ex_report.qmd"
  )
)

# Output: concatenate sub-pipelines
c(
  input_pl,
  main_pl,
  out_pl
)
```
Los bloques fundamentales del _pipeline_ se construyen con la funciÃ³n `tar_target()` cuya estructura bÃ¡sica es
```
tar_target(
  name = target_name
  command = {
    aux_1 = function_1(prev_target_1)
    prev_target_2 %>% 
      function_2(aux_1) %>% 
      function_3()
    }
)
```

:::{.callout-important}
Es importante asegurarse de que el comando de un target tiene un valor de retorno.
:::

Al final del script se debe incluir la lista de todos los targets creados con
`tar_target()` como si del valor de retorno de una funciÃ³n se tratase.

## Correr el _pipeline_
La funciÃ³n que ejecuta las instrucciones puestas en `_targets.R` es `tar_make()`:
```
> tar_make()
â€¢ start target exams_file
â€¢ built target exams_file [0.196 seconds]
â€¢ start target exams
â€¢ built target exams [0.007 seconds]
â€¢ start target model
â€¢ built target model [0.012 seconds]
â€¢ start target plot
â€¢ built target plot [0.014 seconds]
â€¢ end pipeline [0.535 seconds]
```

Esta funciÃ³n comprueba el estado de cada target para no repetir la computaciÃ³n de targets que ya se han ejecutado. En el siguiente ejemplo se muestra el resultado de una segunda llamada a `tar_make()` sin haber cambiado el cÃ³digo ni los datos de entrada:
```
> tar_make()
âœ” skip target exams_file
âœ” skip target exams
âœ” skip target model
âœ” skip target plot
âœ” skip pipeline [0.28 seconds]
```

## Monitorizar el _pipeline_
Para una inspecciÃ³n bÃ¡sica del _pipeline_ tenemos dos opciones principales:

`tar_manifest()` devuelve un `tibble` resumiendo el nombre de cada target y el
comando asociado:
```
> tar_manifest()
# A tibble: 4 Ã— 2
  name       command                                   
  <chr>      <chr>                                     
1 exams_file "\"data/raw/exams.csv\""                  
2 exams      "exams_file %>% fread() %>% rename_data()"
3 model      "fit_model(exams)"                        
4 plot       "plot_model(exams, model)"    
```
No es necesario haber ejecutado `tar_make()` previamente. `tar_manifest()` inspecciona `_targets.R` para extraer la informaciÃ³n de cada target.

Para una representaciÃ³n grÃ¡fica del _pipeline_ tenemos la funciÃ³n `tar_visnetwork()`, que devuelve un grÃ¡fico en html con las dependencias entre targets y en color, el estado de cada uno:

```{r, echo = FALSE}
htmltools::includeHTML("resources/ex_vn_errored.html")
```

:::{.callout-tip}
Para simplificar la _visnetwork_ podemos usar el argumento `targets_only = TRUE`.
:::

Ejemplo de _pipeline_ de la vida real:

```{r, echo = FALSE}
htmltools::includeHTML("resources/ex_vn_reallife.html")
```

Para la monitorizaciÃ³n de proyectos con _pipelines_ mÃ¡s complicados se recomienda el uso de `tar_watch()`. Esta funciÃ³n se debe ejecutar en una nueva sesiÃ³n de RStudio desde el mismo proyecto en que se ejecuta `tar_make()` y abrirÃ¡ un Shiny Dashboard con informaciÃ³n del progreso.

## InspecciÃ³n de resultados
Una vez completado el _pipeline_ existe la opciÃ³n de cargar en el entorno global con `tar_load(target_name)` o de leer directamente el resultado con `tar_read(target_name)` (`tar_name` puede estar indistintamente entrecomillado o no).

```
> tar_read(model$coefficients)
(Intercept)  writing_sc 
  7.9400424   0.9014432 
```

```
tar_read(plot)
```
```{r, echo=FALSE, fig.align='center'}
knitr::include_graphics("resources/model_plot.png")
```

## PresentaciÃ³n de resultados
Hemos hecho un informe de Quarto para presentar los resultados del 
anÃ¡lisis. El script es `ex_report.qmd`, y en Ã©l se especifican los targets que
queremos mostrar como se ha visto en la secciÃ³n anterior, con `tar_read()` y
`tar_load()`. Para renderizar el informe, usamos la funciÃ³n,
`tarchetypes::tar_quarto()`. Ã‰sta no sÃ³lo renderiza el informe, sino que detecta las dependencias entre el informe y el resto de targets, como podemos
verificar en la _visnetwork_:

```{r, echo = FALSE}
htmltools::includeHTML("resources/ex_vn_report.html")
```


## Funcionalidades mÃ¡s avanzadas
- RamificaciÃ³n estÃ¡tica y dinÃ¡mica (static and dynamic branching)
- _Debugging_ con la opciÃ³n `workspace_on_error`
- ComputaciÃ³n en paralelo
